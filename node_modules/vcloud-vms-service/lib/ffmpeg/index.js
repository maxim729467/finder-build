const { execSync, spawn } = require("child_process");

const { getFfmpegStreamArgs, getPID } = require('../helpers/index');

const FFMPEG_STATUS = {
  AWAITING:             "AWAITING",
  IN_PROGRESS:          "IN_PROGRESS",
  STOPPED:              "STOPPED",
  VALIDATION_START:     "VALIDATION_START",
  VALIDATION_COMPLETE:  "VALIDATION_COMPLETE",
};

class FFmpegStream {
  constructor() {
    this.stream = null;
    this.status = FFMPEG_STATUS.AWAITING;
    this.streamId = null; // cameraInfoId
  }

  setStatus(status, pid, code, url) {
    this.status = status;
    if (status === FFMPEG_STATUS.AWAITING) {
      this.setError(null);
      console.log('FFMPEG READY TO STREAM');
    }
    if (status === FFMPEG_STATUS.IN_PROGRESS) {
      console.log(`FFMPEG IS RUNNING, PID: ${pid}`);
    }
    if (status === FFMPEG_STATUS.STOPPED) {
      console.log(`FFMPEG STOPPED WITH CODE: ${code}, PID: ${pid}`);
    }
    if (status === FFMPEG_STATUS.VALIDATION_START) {
      console.log(`FFPROBE TRYING TO CONNECT TO URL: ${url}`);
    }
    if (status === FFMPEG_STATUS.VALIDATION_COMPLETE) {
      console.log(`FFPROBE COMPLETE: ${url}`);
    }
  };

  setStreamId(id) {
    this.streamId = id
  }

  setError(error) {
    this.error = error;
    if (error) {
      console.log(`FFMPEG ERROR: ${error}`)
    }
  };

  async checkUrlIsValid(url) {
    try {
      this.setStatus(FFMPEG_STATUS.VALIDATION_START, null, null, url);
      await execSync(`ffprobe -stimeout 5000000 -v quiet -print_format json -show_error ${url}`);
    } catch (err) {
      this.error = err;
      console.log(`FFPROBE ERROR: ${err}`);
      throw new Error('Url is invalid');
    } finally {
      this.setStatus(FFMPEG_STATUS.VALIDATION_COMPLETE, null, null, url);
    }
  }

  async ffmpegStart(props) {
    const {
      url,
      entryPrefix = '/archive/',
      folderPath,
      fileName = 'output',
      onError = () => {}
    } = props;

    if (this.stream) this.ffmpegStop();

    this.setStatus(FFMPEG_STATUS.AWAITING);

    const args = getFfmpegStreamArgs(url, entryPrefix, folderPath, fileName);

    try {
      this.stream = spawn('ffmpeg', args, {stdio: 'inherit', shell: true});

      this.stream.on('exit', (code) => {
        this.setStatus(FFMPEG_STATUS.STOPPED, getPID(this.stream), code);
        return;
      });

      await new Promise((resolve) => setTimeout(() => {
        if (this.status !== FFMPEG_STATUS.STOPPED) {
          this.setStatus(FFMPEG_STATUS.IN_PROGRESS, getPID(this.stream))
        }
        resolve();
      }, 6000));

    } catch (e) {
      this.setStatus(FFMPEG_STATUS.STOPPED, getPID(this.stream), 1);
      this.setError(e);
      onError(e);
    }
  };

  ffmpegStop() {
    if (this.stream && this.stream.ffmpegProc) this.stream.ffmpegProc.stdin.write('qs');
  };
}

module.exports = FFmpegStream;

// const getHLSUrl = () => {
//   const filePath = `${__dirname}/archive/output.m3u8`;
//   return filePath;
//   fs.readFile(filePath, (error, content) => {
//     if (error) res.send({ error: error });
//     res.end(content);
//   });
// };

// app.get('/download', (req, res) => {
//   exec('for i in `ls *.ts | sort -V`; do echo "file $i"; done >> mylist.txt', (err, stdout, stderr) => {
//     if (err) {
//       //some err occurred
//       console.error(err)
//     } else {
//       // the *entire* stdout and stderr (buffered)
//       console.log(`stdout: ${stdout}`);
//       console.log(`stderr: ${stderr}`);
//     }
//   });
//
//   exec('ffmpeg -f concat -i mylist.txt -c copy -bsf:a aac_adtstoasc dimas.mp4', (err, stdout, stderr) => {
//     if (err) {
//       //some err occurred
//       console.error(err)
//     } else {
//       // the *entire* stdout and stderr (buffered)
//       console.log(`stdout: ${stdout}`);
//       console.log(`stderr: ${stderr}`);
//     }
//   });
//   // ffmpeg('./mylist.txt').inputFormat('concat').mergeToFile('./archive/dimas.mp4', './archive');
//
//   // new ffmpeg(`mylist.txt`)
//   //   .addOptions([
//   //     '-f concat',
//   //     '-c copy',
//   //     '-bsf:a aac_adtstoasc',
//   //   ])
//   //   .save('./archive/dimas.mp4')
//   //   .on('end', function() {
//   console.log('Finished processing');
//   const filePath = `${__dirname}/dimas.mp4`;
//   console.log(filePath);
//   fs.readFile(filePath, (error, content) => {
//     if (error) res.send({ error: error });
//     res.end(content);
//   });
//   // })
// });
